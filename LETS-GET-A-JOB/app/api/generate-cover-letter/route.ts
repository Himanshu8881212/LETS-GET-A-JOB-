import { NextRequest, NextResponse } from 'next/server'
import { exec } from 'child_process'
import { promisify } from 'util'
import fs from 'fs/promises'
import path from 'path'

const execAsync = promisify(exec)

// Escape special LaTeX characters
function escapeLatex(text: string): string {
  if (!text) return ''
  return text
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/&/g, '\\&')
    .replace(/%/g, '\\%')
    .replace(/\$/g, '\\$')
    .replace(/#/g, '\\#')
    .replace(/_/g, '\\_')
    .replace(/\{/g, '\\{')
    .replace(/\}/g, '\\}')
    .replace(/~/g, '\\textasciitilde{}')
    .replace(/\^/g, '\\textasciicircum{}')
}

// Generate dynamic main.tex for cover letter
function generateCoverLetterMainTex(data: any): string {
  const { personalInfo, recipient, content } = data

  const hasName = personalInfo?.firstName || personalInfo?.lastName
  const hasRecipient = recipient?.name || recipient?.company || recipient?.address
  const hasContent = content?.opening || content?.closing ||
    content?.bodyParagraphs?.some((p: string) => p && p.trim().length > 0)

  let mainTex = `\\documentclass[10pt,a4paper]{article}

% Include common files
\\input{../common/preamble.tex}
\\input{../common/layout.tex}
\\input{../common/macros.tex}

% Include cover letter data
\\input{../COVER_LETTER_DATA.tex}

\\begin{document}

`

  // Only include sections if they have data
  if (hasName) {
    mainTex += `\\input{sections/header.tex}\n\n`
  }

  if (hasRecipient) {
    mainTex += `\\input{sections/recipient.tex}\n\n`
  }

  if (hasContent) {
    mainTex += `\\input{sections/body.tex}\n\n`
  }

  if (hasName) {
    mainTex += `\\input{sections/signature.tex}\n`
  }

  mainTex += `\n\\end{document}\n`

  return mainTex
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json()

    // Generate COVER_LETTER_DATA.tex content
    const coverLetterData = generateCoverLetterDataTex(data)

    // Generate dynamic main.tex
    const mainTex = generateCoverLetterMainTex(data)

    // Write to files in current directory (LETS-GET-A-JOB)
    const rootDir = process.cwd()
    const dataFilePath = path.join(rootDir, 'COVER_LETTER_DATA.tex')
    const mainFilePath = path.join(rootDir, 'cover_letter', 'main.tex')

    await fs.writeFile(dataFilePath, coverLetterData)
    await fs.writeFile(mainFilePath, mainTex)

    // Compile PDF
    await execAsync('make cover_letter', { cwd: rootDir })

    // Read PDF
    const pdfPath = path.join(rootDir, 'cover_letter.pdf')
    const pdfBuffer = await fs.readFile(pdfPath)

    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'attachment; filename=cover_letter.pdf'
      }
    })
  } catch (error) {
    console.error('Error generating cover letter:', error)
    return NextResponse.json(
      { error: 'Failed to generate cover letter' },
      { status: 500 }
    )
  }
}

function generateCoverLetterDataTex(data: any): string {
  const { personalInfo, recipient, content } = data

  let tex = `% Cover Letter Data - Generated by Web App
% Personal Information (with CL prefix)
\\newcommand{\\CLFirstName}{${escapeLatex(personalInfo.firstName || '')}}
\\newcommand{\\CLLastName}{${escapeLatex(personalInfo.lastName || '')}}
\\newcommand{\\CLEmail}{${escapeLatex(personalInfo.email || '')}}
\\newcommand{\\CLPhone}{${escapeLatex(personalInfo.phone || '')}}
\\newcommand{\\CLLinkedIn}{${escapeLatex(personalInfo.linkedin || '')}}
\\newcommand{\\CLAddress}{${escapeLatex(personalInfo.address || '')}}

% Personal Information (without prefix for compatibility)
\\newcommand{\\FirstName}{${escapeLatex(personalInfo.firstName || '')}}
\\newcommand{\\LastName}{${escapeLatex(personalInfo.lastName || '')}}
\\newcommand{\\Email}{${escapeLatex(personalInfo.email || '')}}
\\newcommand{\\Phone}{${escapeLatex(personalInfo.phone || '')}}
\\newcommand{\\LinkedIn}{${escapeLatex(personalInfo.linkedin || '')}}
\\newcommand{\\City}{${escapeLatex(personalInfo.address || '')}}
\\newcommand{\\GitHub}{${escapeLatex(personalInfo.github || '')}}

% Recipient Information
\\newcommand{\\CLDate}{${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}}
\\newcommand{\\CLCompany}{${escapeLatex(recipient.company || '')}}
\\newcommand{\\CLRole}{${escapeLatex(recipient.role || '')}}
\\newcommand{\\CLHiringManager}{${escapeLatex(recipient.hiringManager || 'Hiring Manager')}}
\\newcommand{\\CLCompanyAddress}{${escapeLatex(recipient.address || '')}}
\\newcommand{\\CLCompanyCity}{${escapeLatex(recipient.city || '')}}

% Letter Content
\\newcommand{\\CLOpeningParagraph}{${escapeLatex(content.opening || '')}}
`

  // Add body paragraphs - only non-empty ones
  const paragraphNames = ['One', 'Two', 'Three', 'Four', 'Five']
  const actualBodyParagraphs = (content.bodyParagraphs || []).filter((p: string) => p && p.trim())

  actualBodyParagraphs.forEach((paragraph: string, i: number) => {
    tex += `\\newcommand{\\CLBodyParagraph${paragraphNames[i]}}{${escapeLatex(paragraph)}}\n`
  })

  // Fill remaining paragraph slots with empty strings to avoid LaTeX errors
  for (let i = actualBodyParagraphs.length; i < 5; i++) {
    tex += `\\newcommand{\\CLBodyParagraph${paragraphNames[i]}}{}\n`
  }

  tex += `\\newcommand{\\CLClosingParagraph}{${escapeLatex(content.closing || '')}}
`

  return tex
}

